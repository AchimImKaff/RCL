---
API: 2.1
OpenSesame: 3.2.5
Platform: nt
---
set width 1024
set uniform_coordinates yes
set title "Resetting Capacity Limitations"
set subject_parity even
set subject_nr 0
set start program
set sound_sample_size -16
set sound_freq 48000
set sound_channels 2
set sound_buf_size 1024
set sampler_backend legacy
set round_decimals 2
set mouse_backend legacy
set keyboard_backend legacy
set height 768
set fullscreen no
set form_clicks no
set foreground black
set font_underline no
set font_size 32
set font_italic no
set font_family mono
set font_bold no
set experiment_path "D:/User/OpenSesameProjects/RCL"
set disable_garbage_collection yes
set description "A template containing a practice and an experimental phase"
set coordinates uniform
set compensation 0
set color_backend legacy
set clock_backend legacy
set canvas_backend legacy
set bidi yes
set background grey

define inline_script Version
	set description "Executes Python code"
	___run__
	var.program_version = "1.0.2"
	
	""" 
	GitHub: https://github.com/AchimImKaff/RCL
	
	--- General information ---
	Die Einstellung der globalen Parameter erfolgt im Script global_settings (Prepare-Section).
	
	
	--- Change Log ---
	1.0.2
		- Den Code etwas gesäubert / refactored
		
	1.0.1
		- Anzeigeroutine für die UI-Texte zentralisiert
		
	1.0 RC2
		- Support für mehrsprachige Dialoge eingeführt. Die Sprache kann in den global_settings eingestellt werden.
		-- aktuell werden Deutsch (Languages.DE) und Englisch (Languages.EN) unterstützt
		- Programm vereinfacht, in dem unnötige Loops entfernt wurden
	
	0.7 RC1
		- Font-Size vergrößert, damit die Stimuli besser zu erkennen sind. 
		-- https://github.com/AchimImKaff/RCL/issues/2#issue-377982251
		-- Außerdem sollte damit die Größe der Stimuli bei allen Back-Ends gleich sein
		-- Die Definition des Font-Size findet sich im global_settings_script --> [fontSize]
		- Die Anzahl der Durchläufe wird jetzt ebenfalls im global_settings_script festgelegt --> [numOfTrials]
		- Die durchschnittlichen Anzeigedauern (average_letter_duration, average_total_duration) werden mit in die Log-Datei geschrieben.
	
	0.6
		- Bugfix: die Preparation-Section wird offenbar unabhängig von der Bedingung immer ausgeführt. 
		-- Dies führte seltsamerweise bei Back-Ends <> Psycho zum Umschalten des Grafikmodus und der Anzeige-Screen verschwand im Hintergrund.
		-- Daher wird dort jetzt am Anfang das Backend geprüft (if isPsychoBackend == 0|1)
		- Da 15ms offenbar für viele Monitore zu kurz ist, wurde die Anzeigedauer für die Buchstaben auf 33ms (2 Frames) angepasst und ISI auf 66ms
		- Minor Bugfix: Fixation-point: es lagen zwei FP übereinander (weiß und schwarz)
	
	0.5
		- Unterstützung auch für andere Backends als PsychoPy eingeführt (show_stim_any_backend, show_stim_psycho_backend)
		-- hierfür Code nach create_stim_list verlagert und Hilfsfunktionen (helper_functions) eingeführt
		- die zentralen Parameter für die Anzeigedauer der Stimuli ins global_settings_script verlegt
		- Anzeigefarben für die Stimuli zentral im global_settings_script festgelegt
		- die Gesamtzeit (SOA) wird ebenfalls in die Log-Datei geschrieben
		- Bugfix: Es konnten immer noch B, I, O, Q auftauchen
		- Versionierung mit Git via GitHub auf https://github.com/AchimImKaff/RCL
	
	0.4
		- letter duration auf 15 ms und ISI auf 75 ms (wie bei Shapiro)
		- Durchlaufzahl: 90 statt 10 (wie bei Shapiro)
		- Der Begrüßungstext ist jetzt ebenfalls in der 2. Person Singular
	
	0.3
		- Einführung eines Change Log
		- Anzeige einer Versionsnummer im Start-Dialog
		- alle Dialoge jetzt auf Deutsch
		- Die Ziffern 0 und 1 und die Buchstaben B, I, O und Q werden nicht mehr verwendet.
		- Die tatsächlichen Anzeigezeiten der Buchstaben werden in die Log-Datei geschrieben
	"""
	__end__
	set _prepare ""

define inline_script ask_for_T1
	set description "Executes Python code"
	___run__
	showText(curLanguage.ask_for_T1_text(), wait_for_key = False)
	__end__
	set _prepare ""

define inline_script ask_for_T2
	set description "Executes Python code"
	___run__
	showText(curLanguage.ask_for_T2_text(), wait_for_key = False)
	__end__
	set _prepare ""

define form_multiple_choice choice_of_mode
	set timeout infinite
	set spacing 10
	set question "[com_caption]"
	set options "[com_selection]"
	set margins "50;50;50;50"
	set form_var chosen_mode
	set form_title "RCL-Experiment Version [program_version]"
	set description "A simple multiple choice item"
	set button_text Ok
	set allow_multiple no
	set advance_immediately yes
	set _theme gray

define inline_script create_stim_list
	set description "Executes Python code"
	set _run ""
	___prepare__
	""" 
		Creates the list of stimuli including T1 and T2: stim_list[] 
	"""
	import random
	import string
	
	# The position of T1 is random between 7 and 15. Note that the first position is
	# 0, so the position indicates the number of preceding stimuli.
	var.T1_pos = random.randint(7, 15)
	# the position of T2 varies between shortSOA and longSOA
	var.T2_pos = var.T1_pos + var.lag
	
	# The maximum lag, i.e. the number of letters that follow T1.
	var.max_lag = 8
	# The length of the stream is the position of T1 + the maximum lag + 1. We need
	# to add 1, because we count starting at 0, so the length of a list is always
	# 1 larger than its maximum index.
	var.stream_len = var.T1_pos + var.max_lag + 1
	
	# We take all uppercase letters, which have been predefined in the `string`
	# module. Converting to a `list` creates a list of characters.
	letters = list(string.ascii_uppercase)
	letters.remove('B')
	letters.remove('I')
	letters.remove('O')
	letters.remove('Q')
	# As we remove 4 letters, there are not enough letters left to fill the sequence. Hence we add it twice.
	letters += letters;
	
	# Randomly sample a `stream_len` number of letters
	stim_list = random.sample(letters, var.stream_len)
	
	# T1 is a random digit at position T1_pos
	var.T1 = "{0}".format(random.randint(2, 9))
	stim_list[var.T1_pos] = var.T1
	# T2 is a random digit at position T2_pos
	var.T2 = "{0}".format(random.randint(2, 9))
	stim_list[var.T2_pos] = var.T2
	__end__

define inline_script end_text
	set description "Executes Python code"
	set _run "showText(curLanguage.end_text())"
	set _prepare ""

define inline_script evaluate_choice
	set description "Executes Python code"
	___run__
	# Evaluate the choice
	assert(var.chosen_mode != "no") # a choice has to be made
	
	if var.chosen_mode == curLanguage.choice_of_mode_text_experiment():
		var.isTraining = 0
	else:
		var.isTraining = 1
		
	if var.chosen_mode == curLanguage.choice_of_mode_text_training_salient():
		var.isSalient = 1
	else:
		var.isSalient = 0
	
	# There are two ways to create the stimuli implemented in this program depending on the chosen backend
	if var.canvas_backend == "psycho":
		var.isPsychoBackend = 1
	else:
		var.isPsychoBackend = 0
	
	# Delete workaround variables
	del var.com_caption
	del var.com_selection 
	__end__
	set _prepare ""

define loop experiment_block_loop
	set source_file ""
	set source table
	set skip 0
	set repeat "[numOfExperimentRepeats]"
	set order random
	set offset no
	set item trial_sequence
	set description "A single block of trials"
	set cycles 10
	set continuous no
	set column_order ""
	set break_if_on_first yes
	set break_if never
	setcycle 0 lag "[shortSOA]"
	setcycle 1 lag "[shortSOA]"
	setcycle 2 lag "[shortSOA]"
	setcycle 3 lag "[shortSOA]"
	setcycle 4 lag "[shortSOA]"
	setcycle 5 lag "[longSOA]"
	setcycle 6 lag "[longSOA]"
	setcycle 7 lag "[longSOA]"
	setcycle 8 lag "[longSOA]"
	setcycle 9 lag "[longSOA]"
	run trial_sequence

define inline_script experiment_instructions
	set description "Executes Python code"
	set _run "showText(curLanguage.experiment_instructions_text())"
	set _prepare ""

define sequence experimental_sequence
	set flush_keyboard yes
	set description "A sequence containing a single block of trials followed by feedback to the participant"
	run helper_functions always
	run experiment_instructions always
	run reset_feedback always
	run experiment_block_loop always
	run give_feedback always

define sketchpad fixation_point
	set start_response_interval no
	set duration 955
	set description "Displays stimuli"
	draw fixdot color=black show_if=always style=default x=0 y=0 z_index=0

define inline_script give_feedback
	set description "Executes Python code"
	set _run "showText(curLanguage.feedback_text().format(var.acc))"
	set _prepare ""

define inline_script global_settings
	set description "Executes Python code"
	___run__
	# Each experiment loop has 10 values. So the repeat is divided by 10
	var.numOfExperimentRepeats = var.numOfTrials // 10
	assert(var.numOfExperimentRepeats > 0)
	
	# initializing the language
	curLanguage = LanguageFactory(var.dialog_language).getLanguage()
	
	# Just a workaround: standard os-diaglogs can't handle function calls. Therefore we put the strings for the choice_of_mode dialog into global variables.
	var.com_caption = curLanguage.choice_of_mode_text_caption()
	var.com_selection = curLanguage.choice_of_mode_text_experiment() + "\n" + curLanguage.choice_of_mode_text_training_salient() + "\n" + curLanguage.choice_of_mode_text_training_nonsalient()
	__end__
	___prepare__
	""" 
		global settings for experiment and training 
	"""
	# setting UI language
	# Currently supported languages are:
	#  DE: German
	#  EN: English (US)
	var.dialog_language = Languages.DE
	
	# Duration that letters are shown 
	# 	it may be that they must be adjusted to a value compatible with refresh rate of the monitor
	var.letter_dur = 33
	var.isi = 66 	# inter sitmulus interval 
	
	# number of trials used in experiment and training
	var.numOfTrials = 90  # must be a multiple of 10
	
	# Position of T2 in relation to T2 according to experiment 1
	# SOA = stimulus onset asynchrony 
	var.shortSOA = 2
	var.longSOA = 6
	
	# settings for character presentation
	var.standardColor = 'white'
	var.salientColor = 'red'
	var.fontSize = 36
	__end__

define inline_script helper_functions
	set description "Executes Python code"
	set _run ""
	___prepare__
	import numpy
	
	""" cleanString
		Removing CR/LF from a string
		in: s -> str
		return: -> str
	"""
	def cleanString(s):
		return(str(s).replace("\r", "").replace("\n", ""))
	
	""" calcDuration 
		Calculating a list of durations from two lists of times and formatting it as a string without CR/LF
		in:  list1 -> [], list2 -> []
		return: String of durations -> str, average_duration -> int
	"""
	def calcDuration (list1, list2):
		time1 = numpy.array(list1)
		time2 = numpy.array(list2)
		duration = time2 - time1
		average_duration = int(numpy.average(duration))
		return(cleanString(duration), average_duration)
	
	""" showText 
		Showing a dialog with text
		in: text -> str
			text to be displayed
		in: wait_for_key -> bool
			if True the text is displayed until keyboard input	
	"""
	def showText(text = "", wait_for_key = True):
		textCanvas = Canvas()
		textCanvas.text(text, font_size = curLanguage.font_size())
		textCanvas.show()
		if wait_for_key:
			k = Keyboard().get_key()
	__end__

define inline_script language_english
	set description "Executes Python code"
	set _run ""
	___prepare__
	class EnglishLanguage(ILanguageSupport):
		def __init__(self):
			print("Language EN")
	
		def experiment_instructions_text(self):
			return("""
				INSTUCTIONS
				
				You will see a series of letters and two digts at randomly chosen positions.
				
				Afterwards, you will be asked to enter these two digits.
				
				Press any key to continue...
				""")
			
		def training_instructions_text(self):
			return("""
				INSTUCTIONS
				
				You will see a series of letters and two digts at randomly chosen positions.
				The second digit will always appear two letters after the first one.
				
				Afterwards, you will be asked to enter these two digits.
				
				Press any key to continue...
				""")
		
		def choice_of_mode_text_caption(self):
			return("Please select")
			
		def choice_of_mode_text_experiment(self):
			return("Experiment")
			
		def choice_of_mode_text_training_salient(self):
			return("Training with salient digit")
			
		def choice_of_mode_text_training_nonsalient(self):
			return("Training with non-salient digit")
			
		def ask_for_T1_text(self):
			return("Please enter the first digit")
			
		def ask_for_T2_text(self):
			return("Please enter the second digit")
			
		def feedback_text(self):
			return("""
				End of block
				Your accuracy was {0}%
				
				Press any key to continue...
				""")
				
		def end_text(self):
			return("Press any key to finish...")
	__end__

define inline_script language_german
	set description "Executes Python code"
	set _run ""
	___prepare__
	class GermanLanguage(ILanguageSupport):
		def __init__(self):
			print("Language DE")
	
		def experiment_instructions_text(self):
			return("""
				ANLEITUNG
				
				In einer Serie von Buchstaben werden zwei Ziffern an zufällig ausgewählten Positionen gezeigt. 
				
				Bitte identifiziere im Anschluss die beiden Zahlen per Tastatureingabe.
				
				Weiter mit beliebiger Taste...
				""")
				
		def training_instructions_text(self):
			return("""
				TRAININGS-ANLEITUNG
				
				In einer Serie von Buchstaben werden zwei Ziffern an zufällig ausgewählten Positionen gezeigt. 
				Die zweite Ziffer erscheint immer zwei Zeichen nach der ersten. 
				
				Bitte identifiziere im Anschluss die beiden Zahlen per Tastatureingabe.
				
				Weiter mit beliebiger Taste...
				""")
		
		def choice_of_mode_text_caption(self):
			return("Bitte wählen")
			
		def choice_of_mode_text_experiment(self):
			return("Experiment")
			
		def choice_of_mode_text_training_salient(self):
			return("Training mit hervorgehobener Ziffer")
			
		def choice_of_mode_text_training_nonsalient(self):
			return("Training ohne hervorgehobener Ziffer")
			
		def ask_for_T1_text(self):
			return("Wie lautet die erste Ziffer?")
			
		def ask_for_T2_text(self):
			return("Wie lautet die zweite Ziffer?")
			
		def feedback_text(self):
			return("""
				Ende des Blocks
				Die Trefferquote lag bei {0}%
				
				Weiter mit beliebiger Taste...
				""")
				
		def end_text(self):
			return("Zum Beenden eine beliebige Taste drücken...")
	__end__

define sequence language_settings
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run language_support always
	run language_german always
	run language_english always

define inline_script language_support
	set description "Executes Python code"
	set _run ""
	___prepare__
	"""
		Module for handling UI language selection.
		
		Adding a new language is easy:
		1. add a new language selector to the Languages enum (e.g. IT = 3)
		2. add a new class language_<language> derived from ILanguageSupport and overwrite the text-methods. 
			Probably the easiest way is to copy an existing class like language_german.
		3. add a new elif to LanguageFactory.getLanguage returning an instance of this class
	"""
	
	from enum import Enum
	
	class Languages(Enum):
		NONE = 0
		DE = 1
		EN = 2
	
	# base class for language support classes	
	class ILanguageSupport:
		def __init__(self):
			pass
			
		def font_size(self):
			return(24)
				
		def experiment_instructions_text(self):
			return("""Missing experiment_instructions_text""")
				
		def training_instructions_text(self):
			return("""Missing training_instructions_text""")
		
		def choice_of_mode_text_caption(self):
			return("Missing choice_of_mode_text_caption")
			
		def choice_of_mode_text_experiment(self):
			return("Missing choice_of_mode_text_experiment")
			
		def choice_of_mode_text_training_salient(self):
			return("Missing choice_of_mode_text_training_salient")
			
		def choice_of_mode_text_training_nonsalient(self):
			return("Missing choice_of_mode_text_training_nonsalient")
			
		def ask_for_T1_text(self):
			return("Missing ask_for_T1_text")
			
		def ask_for_T2_text(self):
			return("Missing ask_for_T2_text")
			
		def feedback_text(self):
			return("Missing feedback_text")
				
		def end_text(self):
			return("Missing end_text")
	
	class LanguageFactory:
		__languageID = Languages.NONE
		__languageInstance = None
		
		def __init__(self, language):
			self.__languageID = language
			
		def getLanguage(self):
			assert(self.__languageID != Languages.NONE)
			
			if self.__languageInstance is None:
				if self.__languageID == Languages.DE:
					self.__languageInstance = GermanLanguage()
				elif self.__languageID == Languages.EN:
					self.__languageInstance = EnglishLanguage()
				else:
					raise Exception("Language {0} is not supported".format(self.__languageID))
				
			return(self.__languageInstance)
	__end__

define logger logger
	set description "Logs experimental data"
	set auto_log yes

define sequence program
	set flush_keyboard yes
	set description "The main sequence of the experiment"
	run Version always
	run language_settings always
	run global_settings always
	run choice_of_mode always
	run evaluate_choice always
	run experimental_sequence "[isTraining] = 0"
	run training_sequence "[isTraining] = 1"
	run end_text always

define reset_feedback reset_feedback
	set description "Resets the feedback variables, such as 'avg_rt' and 'acc'"

define keyboard_response response_T1
	set timeout infinite
	set flush yes
	set event_type keypress
	set duration keypress
	set description "Collects keyboard responses"
	set correct_response "[T1]"
	set allowed_responses "0;1;2;3;4;5;6;7;8;9"

define keyboard_response response_T2
	set timeout infinite
	set flush yes
	set event_type keypress
	set duration keypress
	set description "Collects keyboard responses"
	set correct_response "[T2]"
	set allowed_responses "0;1;2;3;4;5;6;7;8;9"

define inline_script show_stim_any_backend
	set description "Executes Python code"
	___run__
	"""
		Creates canvas from the list of stimuli (stim_list) and puts them onto the screen 
	"""
	create_canvas()
	show_canvas()
	__end__
	___prepare__
	if var.isPsychoBackend == 0:
		import time
	
		# Create an empty list for the canvas objects.
		letter_canvas_list = []
		# We also need to create a blank canvas to show during the inter-stimulus interval:
		blank_canvas = canvas()
	
		""" 
			Creates a list of canvas containing stimuli 
		"""
		def create_canvas():
			# prepare a list of canvas
			for i, stim in enumerate(stim_list):
				# Create a `canvas` object.
				letter_canvas = canvas()
				
				var.T2_color = var.standardColor 
	
				# while training with salient color, T2 is printed in red 
				if (var.isTraining == 1) and (var.isSalient == 1):
					if i == var.T2_pos:
						var.T2_color = var.salientColor
	
				letter_canvas.set_fgcolor(var.T2_color)
	
				# Draw the letter!
				letter_canvas.text(stim, font_size = var.fontSize)
				# And add the canvas to the list.
				letter_canvas_list.append(letter_canvas)
	
		""" 
			Puts the canvas onto the screen using the defined timing 
		"""
		def show_canvas():
			# Lists for timestamps
			l_letter_time = []
			l_blank_time = []
	
			# Finally putting the canvas onto the screen
			for letter_canvas in letter_canvas_list:
				t1 = letter_canvas.show()
				l_letter_time.append(t1)
				clock.sleep(var.letter_dur)
				t2 = blank_canvas.show()
				l_blank_time.append(t2)
				clock.sleep(var.isi)
	
			(var.actual_letter_duration, var.average_letter_duration)  = calcDuration(l_letter_time, l_blank_time)
	__end__

define inline_script show_stim_psycho_backend
	set description "Executes Python code"
	___run__
	"""
		Creates psycho-visuals from the list of stimuli (stim_list) and puts them onto the screen 
	"""
	create_stim_visuals()
	show_stim_visuals()
	__end__
	___prepare__
	if var.isPsychoBackend == 1:
		import time
		from psychopy import visual
	
		textstim_list = []
		
		""" 
			Creates a list of visuals containing stimuli 
		"""
		def create_stim_visuals():
			# prepare a list of visuals
			for i, stim in enumerate(stim_list):
				color = var.standardColor 
							
				# while training with salient color, T2 is printed in [salientColor] 
				if (var.isTraining == 1) and (var.isSalient == 1):
					if i == var.T2_pos:
						color = var.salientColor
	
				# All stimuli require an psychopy.visual.Window object to be passed as first
				# argument. In OpenSesame, this object is available as `win`.
				textstim = visual.TextStim(win, text=stim, color=color, height = var.fontSize)
				textstim_list.append(textstim)
	
		""" 
			Puts the visuals onto the screen using the defined timing 
		"""
		def show_stim_visuals():
			# Lists for timestamps
			l_letter_time = []
			l_blank_time = []
			l_total_time = []
	
			# Finally putting the visuals onto the screen
			for textstim in textstim_list:
				textstim.draw()
				win.flip()
				l_letter_time.append(time.clock())
				clock.sleep(var.letter_dur)
				win.flip()
				l_blank_time.append(time.clock())
				clock.sleep(var.isi)
				l_total_time.append(time.clock())
	
			(var.actual_letter_duration, var.average_letter_duration)  = calcDuration(l_letter_time, l_blank_time)
			(var.actual_total_duration, var.average_total_duration) = calcDuration(l_letter_time, l_total_time)
	__end__

define loop training_block_loop
	set source_file ""
	set source table
	set repeat "[numOfTrials]"
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 lag "[shortSOA]"
	run trial_sequence

define inline_script training_instructions
	set description "Executes Python code"
	set _run "showText(curLanguage.training_instructions_text())"
	set _prepare ""

define sequence training_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run training_instructions always
	run reset_feedback always
	run training_block_loop always
	run give_feedback always

define sequence trial_sequence
	set flush_keyboard yes
	set description "A single trial"
	run fixation_point always
	run create_stim_list always
	run show_stim_psycho_backend "[isPsychoBackend] = 1"
	run show_stim_any_backend "[isPsychoBackend] = 0"
	run ask_for_T1 always
	run response_T1 always
	run ask_for_T2 always
	run response_T2 always
	run logger always

